{"version":3,"sources":["../src/Collection.js"],"names":["Collection","name","subState","byId","upsert","state","action","newState","Array","isArray","payload","reduce","res","curr","_id","remove","allIds","map","val","push","filter","value","index","self","indexOf","slice","splice"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;;;;;;;;;IAEqBA,U;;;AAEnB,sBAAYC,IAAZ,EAAkBC,QAAlB,EAA4B;AAAA;;AAAA,mHACpBD,IADoB,EACd,EADc;AAExBE,YAAM,oBAAU,MAAV,EAAkB,EAAlB,EAAsB;AAC1BC,gBAAQ,gBAACC,KAAD,EAAQC,MAAR,EAAmB;AACzB,cAAIC,WAAW,EAAf;;AAEA,cAAGC,MAAMC,OAAN,CAAcH,OAAOI,OAArB,CAAH,EAAkC;AAChCH,uBAAWD,OAAOI,OAAP,CAAeC,MAAf,CAAsB,UAACC,GAAD,EAAMC,IAAN,EAAe;AAC9CA,mBAAKC,GAAL,GAAWD,KAAKC,GAAL,IAAY,kBAAvB;AACA,kCAAWF,GAAX,sBAAiBC,KAAKC,GAAtB,EAA4BD,IAA5B;AACD,aAHU,EAGR,EAHQ,CAAX;AAID,WALD,MAMK;AACHP,mBAAOI,OAAP,CAAeI,GAAf,GAAqBR,OAAOI,OAAP,CAAeI,GAAf,IAAsB,kBAA3C;AACAP,2CAAaD,OAAOI,OAAP,CAAeI,GAA5B,EAAkCR,OAAOI,OAAzC;AACD;;AAED,8BACKL,KADL,EAEKE,QAFL;AAID,SAnByB;AAoB1BQ,gBAAQ,gBAACV,KAAD,EAAQC,MAAR,EAAmB;AACzB,cAAIC,wBAAeF,KAAf,CAAJ;AACA,iBAAOE,SAASD,OAAOI,OAAP,CAAeI,GAAxB,CAAP;AACA,iBAAOP,QAAP;AACD;AAxByB,OAAtB,CAFkB;AA4BxBS,cAAQ,oBAAU,QAAV,EAAoB,EAApB,EAAwB;AAC9BZ,gBAAQ,gBAACC,KAAD,EAAQC,MAAR,EAAmB;AACzB,cAAGE,MAAMC,OAAN,CAAcH,OAAOI,OAArB,CAAH,EAAkC;AAChCL,iDAAYA,KAAZ,sBAAsBC,OAAOI,OAAP,CAAeO,GAAf,CAAmB;AAAA,qBAAOC,IAAIJ,GAAX;AAAA,aAAnB,CAAtB;AACD,WAFD,MAGK;AACHT,kBAAMc,IAAN,CAAWb,OAAOI,OAAP,CAAeI,GAA1B;AACD;;AAED,iBAAOT,MAAMe,MAAN,CAAa,UAACC,KAAD,EAAQC,KAAR,EAAeC,IAAf;AAAA,mBAAwBA,KAAKC,OAAL,CAAaH,KAAb,MAAwBC,KAAhD;AAAA,WAAb,CAAP;AACD,SAV6B;AAW9BP,gBAAQ,gBAACV,KAAD,EAAQC,MAAR,EAAmB;AACzB,cAAIC,WAAWF,MAAMoB,KAAN,EAAf;AACAlB,mBAASmB,MAAT,CAAgBnB,SAASiB,OAAT,CAAiBlB,OAAOI,OAAP,CAAeI,GAAhC,CAAhB,EAAsD,CAAtD;AACA,iBAAOP,QAAP;AACD;AAf6B,OAAxB;AA5BgB,OA6CrBL,QA7CqB;AA+C3B;;;;;kBAjDkBF,U","file":"Collection.js","sourcesContent":["import State from './State'\nimport uuidv4 from 'uuid/v4'\n\nexport default class Collection extends State {\n\n  constructor(name, subState) {\n    super(name, {}, {\n      byId: new State('byId', {}, {\n        upsert: (state, action) => {\n          let newState = {}\n\n          if(Array.isArray(action.payload)) {\n            newState = action.payload.reduce((res, curr) => {\n              curr._id = curr._id || uuidv4()\n              return {...res, [curr._id]: curr}\n            }, {})\n          }\n          else {\n            action.payload._id = action.payload._id || uuidv4()\n            newState = {[action.payload._id]: action.payload}\n          }\n\n          return {\n            ...state,\n            ...newState\n          }\n        },\n        remove: (state, action) => {\n          let newState = {...state}\n          delete newState[action.payload._id]\n          return newState\n        }\n      }),\n      allIds: new State('allIds', [], {\n        upsert: (state, action) => {\n          if(Array.isArray(action.payload)) {\n            state = [...state, ...action.payload.map(val => val._id)]\n          }\n          else {\n            state.push(action.payload._id)\n          }\n\n          return state.filter((value, index, self) => self.indexOf(value) === index)\n        },\n        remove: (state, action) => {\n          let newState = state.slice();\n          newState.splice(newState.indexOf(action.payload._id), 1)\n          return newState\n        }\n      }),\n      ...subState\n    })\n  }\n\n}\n"]}